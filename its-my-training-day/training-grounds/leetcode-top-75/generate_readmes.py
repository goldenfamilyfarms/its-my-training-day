import os


BASE_DIR = os.path.join(os.path.dirname(__file__))
OUTPUT_DIR = os.path.join(BASE_DIR, "questions")


TECHNIQUE_DEEP_DIVE = {
    "hash-map": [
        "Use O(1) average lookups to trade space for speed.",
        "Collision handling keeps operations near-constant in practice.",
        "Great for complements, counts, and membership checks.",
    ],
    "greedy": [
        "Track the best choice so far and never revisit earlier states.",
        "Correctness depends on a proven locally optimal rule.",
        "Greedy often reduces to a single pass with constant memory.",
    ],
    "prefix-suffix": [
        "Prefix accumulates left side state; suffix handles right side.",
        "Avoids nested loops by reusing partial results.",
        "Builds outputs in two linear sweeps.",
    ],
    "two-pointers": [
        "Pointers move monotonically to shrink the search space.",
        "Works best on sorted data or symmetric constraints.",
        "Avoids extra memory while keeping linear time.",
    ],
    "binary-search": [
        "Exploit monotonic property to halve the search space.",
        "Update bounds based on which side preserves invariants.",
        "Guarantees O(log n) time on sorted or rotated arrays.",
    ],
    "bitwise": [
        "Bitwise ops compress logic into O(1) space.",
        "XOR cancels identical values; AND clears lowest set bit.",
        "Shift operations walk or construct bit patterns.",
    ],
    "dp-1d": [
        "State depends on a small fixed window of prior states.",
        "Rolling variables replace full arrays for O(1) memory.",
        "Transitions are deterministic and local.",
    ],
    "dp-2d": [
        "Two-dimensional states capture both sequences or grid axes.",
        "Each cell depends on adjacent subproblems.",
        "Often compressible to a single row with care.",
    ],
    "dp-lis": [
        "Maintain minimal tail per length for O(n log n).",
        "Binary search places each value into the tightest slot.",
        "Tail array is not the sequence, only its envelope.",
    ],
    "backtracking": [
        "Explore choices depth-first with pruning on invalid state.",
        "Restore state after each recursive call.",
        "Useful for combinations, paths, and permutations.",
    ],
    "dfs-bfs": [
        "DFS explores depth; BFS explores breadth/levels.",
        "Visited tracking prevents cycles and repeats.",
        "Use DFS for connectivity and BFS for shortest layers.",
    ],
    "topo-sort": [
        "Track indegrees and peel nodes with zero dependencies.",
        "Detect cycles by counting visited nodes.",
        "Builds a valid ordering when constraints form a DAG.",
    ],
    "union-find": [
        "Union merges sets; find locates the representative.",
        "Path compression keeps operations nearly constant.",
        "Great for connectivity and cycle detection.",
    ],
    "intervals-merge": [
        "Sort by start, then merge overlaps in one pass.",
        "Maintain a current interval window.",
        "Overlaps collapse into a single range.",
    ],
    "intervals-greedy": [
        "Sort by end to minimize removals or conflicts.",
        "Pick the earliest finishing intervals first.",
        "Conflicts are detected by comparing boundaries.",
    ],
    "intervals-heap": [
        "Min-heap tracks earliest ending active interval.",
        "Pop when a new interval can reuse a resource.",
        "Heap size equals peak concurrent usage.",
    ],
    "linked-list": [
        "Pointer updates are O(1) once nodes are located.",
        "Dummy nodes simplify head edge cases.",
        "Fast/slow pointers avoid extra passes.",
    ],
    "matrix-in-place": [
        "Reuse matrix borders or sentinel rows/cols for markers.",
        "Avoids extra memory allocations.",
        "In-place transforms preserve O(1) space.",
    ],
    "matrix-traversal": [
        "Shrink boundaries to walk layers.",
        "Move directionally with boundary checks.",
        "Each element visited exactly once.",
    ],
    "matrix-backtracking": [
        "DFS explores 4-neighbor paths with visited marking.",
        "Backtracking restores the cell after exploration.",
        "Prune early on character mismatch.",
    ],
    "sliding-window": [
        "Expand right to include data, shrink left to restore validity.",
        "Counts or last-seen indexes enable O(1) window checks.",
        "Each element enters and leaves the window once.",
    ],
    "stack": [
        "LIFO ordering matches nested structure parsing.",
        "Push on open, pop on close or resolution.",
        "Stack state encodes the current frontier.",
    ],
    "palindrome": [
        "Two-pointer or expand-around-center checks symmetry.",
        "Odd and even centers cover all palindromes.",
        "Early mismatch breaks quickly.",
    ],
    "encoding": [
        "Length-prefix encoding avoids delimiter collisions.",
        "Decode by reading length then slicing.",
        "Round-trip correctness is explicit and deterministic.",
    ],
    "trie": [
        "Each character moves down one level of the tree.",
        "Prefix queries are O(length) regardless of word count.",
        "Nodes mark terminal words for exact match.",
    ],
    "tree-dfs": [
        "Recursive traversal collects or aggregates subtree data.",
        "Postorder is ideal for combine/return patterns.",
        "Null checks guard recursion base cases.",
    ],
    "tree-bfs": [
        "Queue keeps nodes per level for ordered traversal.",
        "Level-size loops isolate each depth.",
        "Useful for views, layer summaries, or serialization.",
    ],
    "tree-bst": [
        "Inorder traversal yields sorted values.",
        "BST constraints prune search to one side.",
        "Range checks validate structure efficiently.",
    ],
    "tree-construct": [
        "Preorder gives root; inorder splits left/right.",
        "Index map avoids repeated linear scans.",
        "Subarray boundaries define subtree recursion.",
    ],
    "tree-serialize": [
        "Level order with null markers preserves structure.",
        "Parsing rebuilds nodes in BFS order.",
        "Stable encoding supports round-trip reconstruction.",
    ],
    "heap": [
        "Heaps keep min/max at the root with O(log n) updates.",
        "Use size to measure concurrent usage or top-k.",
        "Two heaps track lower/upper halves for medians.",
    ],
}


PROBLEMS = [
    {
        "title": "Two Sum",
        "slug": "two-sum",
        "ds": "arrays-hashing",
        "technique": "hash-map",
        "approach": "Scan once while storing seen values; check complement before inserting.",
        "complexity": "Time O(n) | Space O(n)",
        "py_ref": "two_sum",
        "cpp_ref": "twoSum",
        "ts_ref": "twoSum",
    },
    {
        "title": "Best Time to Buy and Sell Stock",
        "slug": "best-time-buy-sell-stock",
        "ds": "arrays-hashing",
        "technique": "greedy",
        "approach": "Track the minimum price so far and update max profit on each day.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "best_time_buy_sell_stock",
        "cpp_ref": "bestTimeBuySellStock",
        "ts_ref": "bestTimeBuySellStock",
    },
    {
        "title": "Contains Duplicate",
        "slug": "contains-duplicate",
        "ds": "arrays-hashing",
        "technique": "hash-map",
        "approach": "Insert elements into a set; if already present, a duplicate exists.",
        "complexity": "Time O(n) | Space O(n)",
        "py_ref": "contains_duplicate",
        "cpp_ref": "containsDuplicate",
        "ts_ref": "containsDuplicate",
    },
    {
        "title": "Product of Array Except Self",
        "slug": "product-except-self",
        "ds": "arrays-hashing",
        "technique": "prefix-suffix",
        "approach": "Build prefix products, then multiply by suffix products in reverse.",
        "complexity": "Time O(n) | Space O(1) extra",
        "py_ref": "product_except_self",
        "cpp_ref": "productExceptSelf",
        "ts_ref": "productExceptSelf",
    },
    {
        "title": "Maximum Subarray",
        "slug": "maximum-subarray",
        "ds": "arrays-hashing",
        "technique": "greedy",
        "approach": "Kadane's algorithm extends or restarts the running sum.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "maximum_subarray",
        "cpp_ref": "maximumSubarray",
        "ts_ref": "maximumSubarray",
    },
    {
        "title": "Maximum Product Subarray",
        "slug": "maximum-product-subarray",
        "ds": "arrays-hashing",
        "technique": "greedy",
        "approach": "Track current max/min products to handle sign flips.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "maximum_product_subarray",
        "cpp_ref": "maximumProductSubarray",
        "ts_ref": "maximumProductSubarray",
    },
    {
        "title": "Find Minimum in Rotated Sorted Array",
        "slug": "find-min-rotated",
        "ds": "arrays-hashing",
        "technique": "binary-search",
        "approach": "Binary search the rotation point using the right boundary.",
        "complexity": "Time O(log n) | Space O(1)",
        "py_ref": "find_min_rotated",
        "cpp_ref": "findMinRotated",
        "ts_ref": "findMinRotated",
    },
    {
        "title": "Search in Rotated Sorted Array",
        "slug": "search-rotated",
        "ds": "arrays-hashing",
        "technique": "binary-search",
        "approach": "Binary search while determining which side is sorted.",
        "complexity": "Time O(log n) | Space O(1)",
        "py_ref": "search_rotated",
        "cpp_ref": "searchRotated",
        "ts_ref": "searchRotated",
    },
    {
        "title": "3Sum",
        "slug": "three-sum",
        "ds": "arrays-hashing",
        "technique": "two-pointers",
        "approach": "Sort then fix one index and use two pointers to find complements.",
        "complexity": "Time O(n^2) | Space O(1) extra",
        "py_ref": "three_sum",
        "cpp_ref": "threeSum",
        "ts_ref": "threeSum",
    },
    {
        "title": "Container With Most Water",
        "slug": "container-with-most-water",
        "ds": "arrays-hashing",
        "technique": "two-pointers",
        "approach": "Move the shorter boundary inward while tracking max area.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "container_with_most_water",
        "cpp_ref": "containerWithMostWater",
        "ts_ref": "containerWithMostWater",
    },
    {
        "title": "Longest Consecutive Sequence",
        "slug": "longest-consecutive",
        "ds": "arrays-hashing",
        "technique": "hash-map",
        "approach": "Start sequences at numbers with no predecessor and extend forward.",
        "complexity": "Time O(n) | Space O(n)",
        "py_ref": "longest_consecutive",
        "cpp_ref": "longestConsecutive",
        "ts_ref": "longestConsecutive",
    },
    {
        "title": "Valid Anagram",
        "slug": "valid-anagram",
        "ds": "arrays-hashing",
        "technique": "hash-map",
        "approach": "Count characters and validate all counts return to zero.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "valid_anagram",
        "cpp_ref": "validAnagram",
        "ts_ref": "validAnagram",
    },
    {
        "title": "Group Anagrams",
        "slug": "group-anagrams",
        "ds": "arrays-hashing",
        "technique": "hash-map",
        "approach": "Use character count signature as a grouping key.",
        "complexity": "Time O(nk) | Space O(nk)",
        "py_ref": "group_anagrams",
        "cpp_ref": "groupAnagrams",
        "ts_ref": "groupAnagrams",
    },
    {
        "title": "Top K Frequent Elements",
        "slug": "top-k-frequent",
        "ds": "arrays-hashing",
        "technique": "heap",
        "approach": "Count frequencies then maintain a size-k min-heap.",
        "complexity": "Time O(n log k) | Space O(n)",
        "py_ref": "top_k_frequent",
        "cpp_ref": "topKFrequent",
        "ts_ref": "topKFrequent",
    },
    {
        "title": "Kth Largest Element in an Array",
        "slug": "kth-largest-in-array",
        "ds": "arrays-hashing",
        "technique": "heap",
        "approach": "Keep a min-heap of size k; root is the kth largest.",
        "complexity": "Time O(n log k) | Space O(k)",
        "py_ref": "kth_largest_in_array",
        "cpp_ref": "kthLargestInArray",
        "ts_ref": "kthLargestInArray",
    },
    {
        "title": "Sum of Two Integers",
        "slug": "sum-of-two-integers",
        "ds": "bit-manipulation",
        "technique": "bitwise",
        "approach": "Use XOR for sum and AND+shift for carry until carry is zero.",
        "complexity": "Time O(1) | Space O(1)",
        "py_ref": "sum_of_two_integers",
        "cpp_ref": "sumOfTwoIntegers",
        "ts_ref": "sumOfTwoIntegers",
    },
    {
        "title": "Number of 1 Bits",
        "slug": "number-of-1-bits",
        "ds": "bit-manipulation",
        "technique": "bitwise",
        "approach": "Clear the lowest set bit repeatedly and count steps.",
        "complexity": "Time O(k) | Space O(1)",
        "py_ref": "number_of_1_bits",
        "cpp_ref": "numberOf1Bits",
        "ts_ref": "numberOf1Bits",
    },
    {
        "title": "Counting Bits",
        "slug": "counting-bits",
        "ds": "bit-manipulation",
        "technique": "bitwise",
        "approach": "DP: bits[i] = bits[i >> 1] + (i & 1).",
        "complexity": "Time O(n) | Space O(n)",
        "py_ref": "counting_bits",
        "cpp_ref": "countingBits",
        "ts_ref": "countingBits",
    },
    {
        "title": "Missing Number",
        "slug": "missing-number",
        "ds": "bit-manipulation",
        "technique": "bitwise",
        "approach": "XOR all indices and values; pairs cancel out.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "missing_number",
        "cpp_ref": "missingNumber",
        "ts_ref": "missingNumber",
    },
    {
        "title": "Reverse Bits",
        "slug": "reverse-bits",
        "ds": "bit-manipulation",
        "technique": "bitwise",
        "approach": "Shift result left and append the lowest bit 32 times.",
        "complexity": "Time O(1) | Space O(1)",
        "py_ref": "reverse_bits",
        "cpp_ref": "reverseBits",
        "ts_ref": "reverseBits",
    },
    {
        "title": "Climbing Stairs",
        "slug": "climbing-stairs",
        "ds": "dynamic-programming",
        "technique": "dp-1d",
        "approach": "Fibonacci-style recurrence with rolling variables.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "climbing_stairs",
        "cpp_ref": "climbingStairs",
        "ts_ref": "climbingStairs",
    },
    {
        "title": "Coin Change",
        "slug": "coin-change",
        "ds": "dynamic-programming",
        "technique": "dp-1d",
        "approach": "Bottom-up DP: dp[i] is min coins to make amount i.",
        "complexity": "Time O(n * c) | Space O(n)",
        "py_ref": "coin_change",
        "cpp_ref": "coinChange",
        "ts_ref": "coinChange",
    },
    {
        "title": "Longest Increasing Subsequence",
        "slug": "longest-increasing-subsequence",
        "ds": "dynamic-programming",
        "technique": "dp-lis",
        "approach": "Maintain minimal tail for each length using binary search.",
        "complexity": "Time O(n log n) | Space O(n)",
        "py_ref": "longest_increasing_subsequence",
        "cpp_ref": "longestIncreasingSubsequence",
        "ts_ref": "longestIncreasingSubsequence",
    },
    {
        "title": "Longest Common Subsequence",
        "slug": "longest-common-subsequence",
        "ds": "dynamic-programming",
        "technique": "dp-2d",
        "approach": "DP grid comparing prefixes of both strings.",
        "complexity": "Time O(n*m) | Space O(n*m)",
        "py_ref": "longest_common_subsequence",
        "cpp_ref": "longestCommonSubsequence",
        "ts_ref": "longestCommonSubsequence",
    },
    {
        "title": "Word Break",
        "slug": "word-break",
        "ds": "dynamic-programming",
        "technique": "dp-1d",
        "approach": "DP over prefixes; dp[i] true if some dp[j] and s[j:i] in dict.",
        "complexity": "Time O(n^2) | Space O(n)",
        "py_ref": "word_break",
        "cpp_ref": "wordBreak",
        "ts_ref": "wordBreak",
    },
    {
        "title": "Combination Sum",
        "slug": "combination-sum",
        "ds": "dynamic-programming",
        "technique": "backtracking",
        "approach": "DFS with pruning; allow reuse by staying at same index.",
        "complexity": "Time O(2^n) | Space O(n)",
        "py_ref": "combination_sum",
        "cpp_ref": "combinationSum",
        "ts_ref": "combinationSum",
    },
    {
        "title": "House Robber",
        "slug": "house-robber",
        "ds": "dynamic-programming",
        "technique": "dp-1d",
        "approach": "Track max of robbing or skipping each house.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "house_robber",
        "cpp_ref": "houseRobber",
        "ts_ref": "houseRobber",
    },
    {
        "title": "House Robber II",
        "slug": "house-robber-ii",
        "ds": "dynamic-programming",
        "technique": "dp-1d",
        "approach": "Run House Robber twice, excluding first or last house.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "house_robber_ii",
        "cpp_ref": "houseRobberII",
        "ts_ref": "houseRobberII",
    },
    {
        "title": "Decode Ways",
        "slug": "decode-ways",
        "ds": "dynamic-programming",
        "technique": "dp-1d",
        "approach": "DP on index with 1- and 2-digit transitions.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "decode_ways",
        "cpp_ref": "decodeWays",
        "ts_ref": "decodeWays",
    },
    {
        "title": "Unique Paths",
        "slug": "unique-paths",
        "ds": "dynamic-programming",
        "technique": "dp-2d",
        "approach": "DP on grid with dp[r][c] = top + left.",
        "complexity": "Time O(mn) | Space O(n)",
        "py_ref": "unique_paths",
        "cpp_ref": "uniquePaths",
        "ts_ref": "uniquePaths",
    },
    {
        "title": "Jump Game",
        "slug": "jump-game",
        "ds": "dynamic-programming",
        "technique": "greedy",
        "approach": "Track the farthest reachable index while scanning.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "jump_game",
        "cpp_ref": "jumpGame",
        "ts_ref": "jumpGame",
    },
    {
        "title": "Clone Graph",
        "slug": "clone-graph",
        "ds": "graphs",
        "technique": "dfs-bfs",
        "approach": "DFS with hashmap to clone nodes and neighbors.",
        "complexity": "Time O(V+E) | Space O(V)",
        "py_ref": "clone_graph",
        "cpp_ref": "cloneGraph",
        "ts_ref": "cloneGraph",
    },
    {
        "title": "Course Schedule",
        "slug": "course-schedule",
        "ds": "graphs",
        "technique": "topo-sort",
        "approach": "Kahn's algorithm using indegrees and a queue.",
        "complexity": "Time O(V+E) | Space O(V+E)",
        "py_ref": "course_schedule",
        "cpp_ref": "courseSchedule",
        "ts_ref": "courseSchedule",
    },
    {
        "title": "Pacific Atlantic Water Flow",
        "slug": "pacific-atlantic",
        "ds": "graphs",
        "technique": "dfs-bfs",
        "approach": "Reverse-flow DFS from borders into higher/equal cells.",
        "complexity": "Time O(mn) | Space O(mn)",
        "py_ref": "pacific_atlantic",
        "cpp_ref": "pacificAtlantic",
        "ts_ref": "pacificAtlantic",
    },
    {
        "title": "Number of Islands",
        "slug": "number-of-islands",
        "ds": "graphs",
        "technique": "dfs-bfs",
        "approach": "DFS flood-fill each land cell to mark visited.",
        "complexity": "Time O(mn) | Space O(mn)",
        "py_ref": "number_of_islands",
        "cpp_ref": "numberOfIslands",
        "ts_ref": "numberOfIslands",
    },
    {
        "title": "Alien Dictionary",
        "slug": "alien-dictionary",
        "ds": "graphs",
        "technique": "topo-sort",
        "approach": "Build precedence edges from adjacent words then topo sort.",
        "complexity": "Time O(V+E) | Space O(V+E)",
        "py_ref": "alien_dictionary",
        "cpp_ref": "alienDictionary",
        "ts_ref": "alienDictionary",
    },
    {
        "title": "Graph Valid Tree",
        "slug": "graph-valid-tree",
        "ds": "graphs",
        "technique": "union-find",
        "approach": "Tree requires n-1 edges and no cycles in union-find.",
        "complexity": "Time O(E α(n)) | Space O(n)",
        "py_ref": "graph_valid_tree",
        "cpp_ref": "graphValidTree",
        "ts_ref": "graphValidTree",
    },
    {
        "title": "Number of Connected Components in an Undirected Graph",
        "slug": "connected-components",
        "ds": "graphs",
        "technique": "union-find",
        "approach": "Union edges and count distinct parents.",
        "complexity": "Time O(E α(n)) | Space O(n)",
        "py_ref": "number_of_connected_components",
        "cpp_ref": "numberOfConnectedComponents",
        "ts_ref": "numberOfConnectedComponents",
    },
    {
        "title": "Insert Interval",
        "slug": "insert-interval",
        "ds": "intervals",
        "technique": "intervals-merge",
        "approach": "Append non-overlapping, merge overlaps, then add the rest.",
        "complexity": "Time O(n) | Space O(n)",
        "py_ref": "insert_interval",
        "cpp_ref": "insertInterval",
        "ts_ref": "insertInterval",
    },
    {
        "title": "Merge Intervals",
        "slug": "merge-intervals",
        "ds": "intervals",
        "technique": "intervals-merge",
        "approach": "Sort by start and coalesce overlapping ranges.",
        "complexity": "Time O(n log n) | Space O(n)",
        "py_ref": "merge_intervals",
        "cpp_ref": "mergeIntervals",
        "ts_ref": "mergeIntervals",
    },
    {
        "title": "Non-overlapping Intervals",
        "slug": "non-overlapping-intervals",
        "ds": "intervals",
        "technique": "intervals-greedy",
        "approach": "Sort by start and greedily keep the smallest end on overlap.",
        "complexity": "Time O(n log n) | Space O(1)",
        "py_ref": "non_overlapping_intervals",
        "cpp_ref": "nonOverlappingIntervals",
        "ts_ref": "nonOverlappingIntervals",
    },
    {
        "title": "Meeting Rooms",
        "slug": "meeting-rooms",
        "ds": "intervals",
        "technique": "intervals-greedy",
        "approach": "Sort by start and detect any overlap.",
        "complexity": "Time O(n log n) | Space O(1)",
        "py_ref": "meeting_rooms",
        "cpp_ref": "meetingRooms",
        "ts_ref": "meetingRooms",
    },
    {
        "title": "Meeting Rooms II",
        "slug": "meeting-rooms-ii",
        "ds": "intervals",
        "technique": "intervals-heap",
        "approach": "Use a min-heap of end times to reuse rooms.",
        "complexity": "Time O(n log n) | Space O(n)",
        "py_ref": "meeting_rooms_ii",
        "cpp_ref": "meetingRoomsII",
        "ts_ref": "meetingRoomsII",
    },
    {
        "title": "Reverse Linked List",
        "slug": "reverse-linked-list",
        "ds": "linked-list",
        "technique": "linked-list",
        "approach": "Iteratively reverse pointers with prev/curr/next.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "reverse_linked_list",
        "cpp_ref": "reverseLinkedList",
        "ts_ref": "reverseLinkedList",
    },
    {
        "title": "Detect Cycle in Linked List",
        "slug": "detect-cycle",
        "ds": "linked-list",
        "technique": "linked-list",
        "approach": "Floyd's fast/slow pointers detect a loop.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "detect_cycle",
        "cpp_ref": "detectCycle",
        "ts_ref": "detectCycle",
    },
    {
        "title": "Merge Two Sorted Lists",
        "slug": "merge-two-sorted-lists",
        "ds": "linked-list",
        "technique": "linked-list",
        "approach": "Merge with a dummy head and pointer advances.",
        "complexity": "Time O(m+n) | Space O(1)",
        "py_ref": "merge_two_sorted_lists",
        "cpp_ref": "mergeTwoSortedLists",
        "ts_ref": "mergeTwoSortedLists",
    },
    {
        "title": "Merge K Sorted Lists",
        "slug": "merge-k-sorted-lists",
        "ds": "linked-list",
        "technique": "heap",
        "approach": "Push list heads into a min-heap and pop in order.",
        "complexity": "Time O(n log k) | Space O(k)",
        "py_ref": "merge_k_sorted_lists",
        "cpp_ref": "mergeKSortedLists",
        "ts_ref": "mergeKSortedLists",
    },
    {
        "title": "Remove Nth Node From End",
        "slug": "remove-nth-from-end",
        "ds": "linked-list",
        "technique": "linked-list",
        "approach": "Two pointers with a gap of n+1 and a dummy head.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "remove_nth_from_end",
        "cpp_ref": "removeNthFromEnd",
        "ts_ref": "removeNthFromEnd",
    },
    {
        "title": "Reorder List",
        "slug": "reorder-list",
        "ds": "linked-list",
        "technique": "linked-list",
        "approach": "Find middle, reverse second half, then weave lists.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "reorder_list",
        "cpp_ref": "reorderList",
        "ts_ref": "reorderList",
    },
    {
        "title": "Set Matrix Zeroes",
        "slug": "set-matrix-zeroes",
        "ds": "matrix",
        "technique": "matrix-in-place",
        "approach": "Use first row/column as markers and track initial zeros.",
        "complexity": "Time O(mn) | Space O(1)",
        "py_ref": "set_matrix_zeroes",
        "cpp_ref": "setMatrixZeroes",
        "ts_ref": "setMatrixZeroes",
    },
    {
        "title": "Spiral Matrix",
        "slug": "spiral-matrix",
        "ds": "matrix",
        "technique": "matrix-traversal",
        "approach": "Traverse layers with shrinking boundaries.",
        "complexity": "Time O(mn) | Space O(1)",
        "py_ref": "spiral_matrix",
        "cpp_ref": "spiralMatrix",
        "ts_ref": "spiralMatrix",
    },
    {
        "title": "Rotate Image",
        "slug": "rotate-image",
        "ds": "matrix",
        "technique": "matrix-in-place",
        "approach": "Rotate layer by layer swapping four cells at a time.",
        "complexity": "Time O(n^2) | Space O(1)",
        "py_ref": "rotate_image",
        "cpp_ref": "rotateImage",
        "ts_ref": "rotateImage",
    },
    {
        "title": "Word Search",
        "slug": "word-search",
        "ds": "matrix",
        "technique": "matrix-backtracking",
        "approach": "DFS with visited marking for each start cell.",
        "complexity": "Time O(mn*4^k) | Space O(k)",
        "py_ref": "word_search",
        "cpp_ref": "wordSearch",
        "ts_ref": "wordSearch",
    },
    {
        "title": "Longest Substring Without Repeating Characters",
        "slug": "longest-substring-no-repeat",
        "ds": "strings",
        "technique": "sliding-window",
        "approach": "Track last seen index to move the left boundary quickly.",
        "complexity": "Time O(n) | Space O(k)",
        "py_ref": "longest_substring_without_repeating",
        "cpp_ref": "longestSubstringWithoutRepeating",
        "ts_ref": "longestSubstringWithoutRepeating",
    },
    {
        "title": "Longest Repeating Character Replacement",
        "slug": "longest-repeating-replacement",
        "ds": "strings",
        "technique": "sliding-window",
        "approach": "Track max frequency in window and shrink when replacements exceed k.",
        "complexity": "Time O(n) | Space O(k)",
        "py_ref": "longest_repeating_character_replacement",
        "cpp_ref": "longestRepeatingCharacterReplacement",
        "ts_ref": "longestRepeatingCharacterReplacement",
    },
    {
        "title": "Minimum Window Substring",
        "slug": "minimum-window-substring",
        "ds": "strings",
        "technique": "sliding-window",
        "approach": "Expand to satisfy all counts, then shrink to minimize.",
        "complexity": "Time O(n) | Space O(k)",
        "py_ref": "minimum_window_substring",
        "cpp_ref": "minimumWindowSubstring",
        "ts_ref": "minimumWindowSubstring",
    },
    {
        "title": "Valid Parentheses",
        "slug": "valid-parentheses",
        "ds": "strings",
        "technique": "stack",
        "approach": "Push openings and pop on closing bracket mismatches.",
        "complexity": "Time O(n) | Space O(n)",
        "py_ref": "valid_parentheses",
        "cpp_ref": "validParentheses",
        "ts_ref": "validParentheses",
    },
    {
        "title": "Valid Palindrome",
        "slug": "valid-palindrome",
        "ds": "strings",
        "technique": "palindrome",
        "approach": "Two pointers skip non-alphanumerics and compare lowercased chars.",
        "complexity": "Time O(n) | Space O(1)",
        "py_ref": "valid_palindrome",
        "cpp_ref": "validPalindrome",
        "ts_ref": "validPalindrome",
    },
    {
        "title": "Longest Palindromic Substring",
        "slug": "longest-palindromic-substring",
        "ds": "strings",
        "technique": "palindrome",
        "approach": "Expand around each center for odd/even palindromes.",
        "complexity": "Time O(n^2) | Space O(1)",
        "py_ref": "longest_palindromic_substring",
        "cpp_ref": "longestPalindromicSubstring",
        "ts_ref": "longestPalindromicSubstring",
    },
    {
        "title": "Palindromic Substrings",
        "slug": "palindromic-substrings",
        "ds": "strings",
        "technique": "palindrome",
        "approach": "Count palindromes by expanding around each center.",
        "complexity": "Time O(n^2) | Space O(1)",
        "py_ref": "palindromic_substrings",
        "cpp_ref": "palindromicSubstrings",
        "ts_ref": "palindromicSubstrings",
    },
    {
        "title": "Encode and Decode Strings",
        "slug": "encode-decode-strings",
        "ds": "strings",
        "technique": "encoding",
        "approach": "Use length-prefix encoding; decode by reading length then slice.",
        "complexity": "Time O(n) | Space O(n)",
        "py_ref": "encode_strings / decode_strings",
        "cpp_ref": "encodeStrings / decodeStrings",
        "ts_ref": "encodeStrings / decodeStrings",
    },
    {
        "title": "Implement Trie (Prefix Tree)",
        "slug": "implement-trie",
        "ds": "strings",
        "technique": "trie",
        "approach": "Each node stores children and end-of-word flag.",
        "complexity": "Time O(k) | Space O(k * alphabet)",
        "py_ref": "Trie",
        "cpp_ref": "Trie",
        "ts_ref": "Trie",
    },
    {
        "title": "Maximum Depth of Binary Tree",
        "slug": "max-depth-binary-tree",
        "ds": "trees",
        "technique": "tree-dfs",
        "approach": "Depth-first recursion returns max of left/right depths.",
        "complexity": "Time O(n) | Space O(h)",
        "py_ref": "max_depth_binary_tree",
        "cpp_ref": "maxDepthBinaryTree",
        "ts_ref": "maxDepthBinaryTree",
    },
    {
        "title": "Same Tree",
        "slug": "same-tree",
        "ds": "trees",
        "technique": "tree-dfs",
        "approach": "Compare nodes recursively in preorder.",
        "complexity": "Time O(n) | Space O(h)",
        "py_ref": "same_tree",
        "cpp_ref": "sameTree",
        "ts_ref": "sameTree",
    },
    {
        "title": "Invert Binary Tree",
        "slug": "invert-binary-tree",
        "ds": "trees",
        "technique": "tree-dfs",
        "approach": "Swap left/right recursively.",
        "complexity": "Time O(n) | Space O(h)",
        "py_ref": "invert_binary_tree",
        "cpp_ref": "invertBinaryTree",
        "ts_ref": "invertBinaryTree",
    },
    {
        "title": "Binary Tree Maximum Path Sum",
        "slug": "binary-tree-max-path-sum",
        "ds": "trees",
        "technique": "tree-dfs",
        "approach": "Postorder DFS returns max gain; update global best.",
        "complexity": "Time O(n) | Space O(h)",
        "py_ref": "binary_tree_max_path_sum",
        "cpp_ref": "binaryTreeMaxPathSum",
        "ts_ref": "binaryTreeMaxPathSum",
    },
    {
        "title": "Binary Tree Level Order Traversal",
        "slug": "binary-tree-level-order",
        "ds": "trees",
        "technique": "tree-bfs",
        "approach": "BFS with level-size loops to build layers.",
        "complexity": "Time O(n) | Space O(w)",
        "py_ref": "binary_tree_level_order",
        "cpp_ref": "binaryTreeLevelOrder",
        "ts_ref": "binaryTreeLevelOrder",
    },
    {
        "title": "Serialize and Deserialize Binary Tree",
        "slug": "serialize-deserialize-binary-tree",
        "ds": "trees",
        "technique": "tree-serialize",
        "approach": "Level-order traversal with null markers for structure.",
        "complexity": "Time O(n) | Space O(n)",
        "py_ref": "serialize_binary_tree / deserialize_binary_tree",
        "cpp_ref": "serializeBinaryTree / deserializeBinaryTree",
        "ts_ref": "serializeBinaryTree / deserializeBinaryTree",
    },
    {
        "title": "Subtree of Another Tree",
        "slug": "subtree-of-another-tree",
        "ds": "trees",
        "technique": "tree-dfs",
        "approach": "DFS each node and compare subtree equality.",
        "complexity": "Time O(n*m) | Space O(h)",
        "py_ref": "subtree_of_another_tree",
        "cpp_ref": "subtreeOfAnotherTree",
        "ts_ref": "subtreeOfAnotherTree",
    },
    {
        "title": "Construct Binary Tree from Preorder and Inorder",
        "slug": "construct-tree-pre-in",
        "ds": "trees",
        "technique": "tree-construct",
        "approach": "Use preorder root and inorder split with index map.",
        "complexity": "Time O(n) | Space O(n)",
        "py_ref": "build_tree_pre_in",
        "cpp_ref": "buildTreePreIn",
        "ts_ref": "buildTreePreIn",
    },
    {
        "title": "Validate Binary Search Tree",
        "slug": "validate-bst",
        "ds": "trees",
        "technique": "tree-bst",
        "approach": "DFS with value bounds for each subtree.",
        "complexity": "Time O(n) | Space O(h)",
        "py_ref": "validate_bst",
        "cpp_ref": "validateBST",
        "ts_ref": "validateBST",
    },
    {
        "title": "Kth Smallest Element in a BST",
        "slug": "kth-smallest-bst",
        "ds": "trees",
        "technique": "tree-bst",
        "approach": "Inorder traversal counting nodes until k.",
        "complexity": "Time O(n) | Space O(h)",
        "py_ref": "kth_smallest_bst",
        "cpp_ref": "kthSmallestBST",
        "ts_ref": "kthSmallestBST",
    },
    {
        "title": "Lowest Common Ancestor of BST",
        "slug": "lca-bst",
        "ds": "trees",
        "technique": "tree-bst",
        "approach": "Use BST ordering to walk down to the split point.",
        "complexity": "Time O(h) | Space O(1)",
        "py_ref": "lca_bst",
        "cpp_ref": "lcaBST",
        "ts_ref": "lcaBST",
    },
    {
        "title": "Binary Tree Right Side View",
        "slug": "binary-tree-right-side-view",
        "ds": "trees",
        "technique": "tree-bfs",
        "approach": "BFS by level and record the last node at each depth.",
        "complexity": "Time O(n) | Space O(w)",
        "py_ref": "binary_tree_right_side_view",
        "cpp_ref": "binaryTreeRightSideView",
        "ts_ref": "binaryTreeRightSideView",
    },
    {
        "title": "Find Median from Data Stream",
        "slug": "median-from-data-stream",
        "ds": "heap",
        "technique": "heap",
        "approach": "Maintain max-heap for lower half and min-heap for upper half.",
        "complexity": "Time O(log n) | Space O(n)",
        "py_ref": "MedianFinder",
        "cpp_ref": "MedianFinder",
        "ts_ref": "MedianFinder",
    },
]


def ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)


def build_readme(problem: dict) -> str:
    deep_dive = TECHNIQUE_DEEP_DIVE.get(problem["technique"], [])
    deep_dive_md = "\n".join([f"- {item}" for item in deep_dive])
    return f"""# {problem['title']}

## Directory
- Data structure: `{problem['ds']}`
- Technique: `{problem['technique']}`

## Approach
{problem['approach']}

## Data Structure Deep Dive
{deep_dive_md if deep_dive_md else "- See shared implementations for structural details."}

## Complexity
{problem['complexity']}

## Solution References
- Python: `solution.py` → `{problem['py_ref']}`
- C++: `solution.cpp` → `{problem['cpp_ref']}`
- TypeScript: `solution.ts` → `{problem['ts_ref']}`
"""


def main() -> None:
    ensure_dir(OUTPUT_DIR)
    index_lines = [
        "# LeetCode Top 75",
        "",
        "Organized by data structure and technique.",
        "",
    ]
    for problem in PROBLEMS:
        ds_dir = os.path.join(OUTPUT_DIR, problem["ds"], problem["technique"], problem["slug"])
        ensure_dir(ds_dir)
        readme_path = os.path.join(ds_dir, "README.md")
        with open(readme_path, "w", encoding="utf-8") as f:
            f.write(build_readme(problem))
        index_lines.append(f"- {problem['title']} → `{os.path.relpath(readme_path, BASE_DIR)}`")

    index_path = os.path.join(BASE_DIR, "README.md")
    with open(index_path, "w", encoding="utf-8") as f:
        f.write("\n".join(index_lines))


if __name__ == "__main__":
    main()
